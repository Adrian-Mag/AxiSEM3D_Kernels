

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>axikernels.core.handlers.element_output &mdash; Axikernels 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=2709fde1"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            Axikernels
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">axikernels</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Axikernels</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">axikernels.core.handlers.element_output</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for axikernels.core.handlers.element_output</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">axikernels.core.handlers.axisem3d_output</span><span class="w"> </span><span class="kn">import</span> <span class="n">AxiSEM3DOutput</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">axikernels.aux.coordinate_transforms</span><span class="w"> </span><span class="kn">import</span> <span class="n">sph2cart</span><span class="p">,</span> <span class="n">sph2cart_mpmath</span><span class="p">,</span> <span class="n">cart2sph</span><span class="p">,</span> <span class="n">cart2polar</span><span class="p">,</span> <span class="n">cart2polar_mpmath</span><span class="p">,</span> <span class="n">cart_geo2cart_src</span><span class="p">,</span> <span class="n">cart2cyl</span><span class="p">,</span> <span class="n">cart2cyl_mpmath</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">axikernels.aux.mesher</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mesh</span><span class="p">,</span> <span class="n">SliceMesh</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.animation</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">animation</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">yaml</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">obspy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">obspy.core.inventory</span><span class="w"> </span><span class="kn">import</span> <span class="n">Inventory</span><span class="p">,</span> <span class="n">Network</span><span class="p">,</span> <span class="n">Station</span><span class="p">,</span> <span class="n">Channel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">concurrent.futures</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">plotly.graph_objects</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">go</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">netCDF4</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nc</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">CRITICAL</span><span class="p">,</span>
                    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># warnings.filterwarnings(&quot;error&quot;)</span>


<div class="viewcode-block" id="ElementOutput">
<a class="viewcode-back" href="../../../../axikernels.core.handlers.html#axikernels.core.handlers.element_output.ElementOutput">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ElementOutput</span><span class="p">(</span><span class="n">AxiSEM3DOutput</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_element_output</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the ElementOutput object for the given path to the</span>
<span class="sd">        element output directory.</span>

<span class="sd">        Args:</span>
<span class="sd">            path_to_element_output (str): Path to the element output directory</span>
<span class="sd">            (called &quot;elements&quot;).</span>

<span class="sd">        Attributes:</span>
<span class="sd">            path_to_elements_output (str): Path to the element output</span>
<span class="sd">            directory.</span>
<span class="sd">            element_groups_info (Dict[str, Any]): Information about all the</span>
<span class="sd">            element groups.</span>
<span class="sd">            source_lat (float): Latitude of the event located on the axis.</span>
<span class="sd">            source_lon (float): Longitude of the event located on the axis.</span>
<span class="sd">            source_depth (float): Depth of the event located on the axis.</span>
<span class="sd">            rotation_matrix (np.ndarray): Rotation matrix for the wavefields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_to_simulation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_simulation_path</span><span class="p">(</span><span class="n">path_to_element_output</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">path_to_simulation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_to_elements_output</span> <span class="o">=</span> <span class="n">path_to_element_output</span>

        <span class="c1"># Load element groups information from the inparam output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_element_groups_info</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element_groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Get lat lon of the event located on the axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_source_location</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Create the metadata for each element group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_elements_info</span><span class="p">()</span>

        <span class="c1"># Compute rotation matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotation_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_rotation_matrix</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_simulation_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            path_to_station_file (str): path to station.txt file</span>

<span class="sd">        Returns:</span>
<span class="sd">            parent_directory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">parent_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">current_directory</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;output&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">current_directory</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">parent_directory</span>
            <span class="k">elif</span> <span class="n">current_directory</span> <span class="o">==</span> <span class="n">parent_directory</span><span class="p">:</span>
                <span class="c1"># Reached the root directory, &quot;output&quot; directory not found</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">current_directory</span> <span class="o">=</span> <span class="n">parent_directory</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_element_groups_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load element groups information from the inparam output.&quot;&quot;&quot;</span>
        <span class="n">element_groups_info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inparam_output</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">output_yaml</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">Loader</span><span class="o">=</span><span class="n">yaml</span><span class="o">.</span><span class="n">FullLoader</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dictionary</span> <span class="ow">in</span> <span class="n">output_yaml</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;list_of_element_groups&#39;</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">element_group</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dictionary</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">element_group</span><span class="p">:</span>
                    <span class="n">element_groups_info</span><span class="p">[</span><span class="n">element_group</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">dictionary</span><span class="p">[</span><span class="n">element_group</span><span class="p">]</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">element_groups_info</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_source_location</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get latitude, longitude, and depth of the event located on the</span>
<span class="sd">        axis.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inparam_source</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">source_yaml</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">Loader</span><span class="o">=</span><span class="n">yaml</span><span class="o">.</span><span class="n">FullLoader</span><span class="p">)</span>
            <span class="n">source_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">source_yaml</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;list_of_sources&#39;</span><span class="p">,</span> <span class="p">[{}])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Assume a single point source</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">source_yaml</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;list_of_sources&#39;</span><span class="p">,</span> <span class="p">[{}])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">source_name</span><span class="p">,</span> <span class="p">{}</span>
            <span class="p">)</span>
            <span class="n">source_lat</span><span class="p">,</span> <span class="n">source_lon</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s1">&#39;latitude_longitude&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">source_depth</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;depth&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">source_lat</span><span class="p">,</span> <span class="n">source_lon</span><span class="p">,</span> <span class="n">source_depth</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_elements_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populates the &#39;metadata&#39; field for each element in</span>
<span class="sd">        `element_groups_info`.</span>

<span class="sd">        This method iterates over each element in `element_groups_info`, reads</span>
<span class="sd">        its metadata using `_read_element_metadata`, and stores it in a</span>
<span class="sd">        dictionary under the &#39;metadata&#39; key. The metadata includes information</span>
<span class="sd">        such as &#39;na_grid&#39;, &#39;data_time&#39;, &#39;list_element_na&#39;,</span>
<span class="sd">        &#39;list_element_coords&#39;, &#39;dict_list_element&#39;, &#39;files&#39;,</span>
<span class="sd">        &#39;elements_index_limits&#39;, and &#39;detailed_channels&#39;.</span>

<span class="sd">        Additionally, it replaces numerical indicators of coordinates in</span>
<span class="sd">        &#39;detailed_channels&#39; with letters based on the coordinate system</span>
<span class="sd">        specified in &#39;coordinate_frame&#39;.</span>

<span class="sd">        Note: This method modifies `element_groups_info` in-place.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Any exceptions raised by `_read_element_metadata`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">element_group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_element_metadata</span><span class="p">(</span><span class="n">element_group</span><span class="p">)</span>
            <span class="c1"># at this point we have all the information from the inparam.output</span>
            <span class="c1"># about each element group, except for the information aboout the actual data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">element_group</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;na_grid&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;data_time&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;list_element_na&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="s1">&#39;list_element_coords&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                <span class="s1">&#39;dict_list_element&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                <span class="s1">&#39;files&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
                <span class="s1">&#39;elements_index_limits&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
                <span class="s1">&#39;detailed_channels&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
            <span class="p">}</span>

            <span class="c1"># Replace the numerical indicators of coordinates with letters</span>
            <span class="c1"># based on the coordinate system</span>
            <span class="n">coordinate_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">element_group</span><span class="p">][</span><span class="s1">&#39;wavefields&#39;</span><span class="p">][</span><span class="s1">&#39;coordinate_frame&#39;</span><span class="p">]</span> <span class="c1"># noqa</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">element_group</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;detailed_channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="c1"># noqa</span>
                <span class="n">element</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">coordinate_frame</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                       <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="n">coordinate_frame</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                       <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="n">coordinate_frame</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">element_group</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;detailed_channels&#39;</span><span class="p">]</span> <span class="c1"># noqa</span>
            <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_rotation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the rotation matrix that aligns the z axis with the source</span>
<span class="sd">        axis</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: 3D rotation matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get real earth coordinates of the sources</span>
        <span class="n">colatitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_lat</span><span class="p">)</span>
        <span class="n">longitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_lon</span><span class="p">)</span>

        <span class="c1"># rotation matrix into the source frame (based on Tarje&#39;s PhD)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">colatitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">longitude</span><span class="p">),</span>
                            <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">longitude</span><span class="p">),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">colatitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">longitude</span><span class="p">)],</span>
                           <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">colatitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">longitude</span><span class="p">),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">longitude</span><span class="p">),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">colatitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">longitude</span><span class="p">)],</span>
                           <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">colatitude</span><span class="p">),</span>
                            <span class="mi">0</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">colatitude</span><span class="p">)]])</span>

<div class="viewcode-block" id="ElementOutput.plot_mesh">
<a class="viewcode-back" href="../../../../axikernels.core.handlers.html#axikernels.core.handlers.element_output.ElementOutput.plot_mesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">special_elements</span><span class="p">):</span>
        <span class="n">problematic_elements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_element_coords</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">element</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">element</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">cart2polar</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">points</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">points</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">r_grid</span><span class="p">,</span> <span class="n">theta_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="n">expected_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">r_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                               <span class="n">theta_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">expected_points</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
                <span class="n">problematic_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="n">all_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_element_coords</span><span class="p">[</span><span class="n">problematic_elements</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># noqa</span>
        <span class="n">unique_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">s_coords</span> <span class="o">=</span> <span class="n">unique_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">z_coords</span> <span class="o">=</span> <span class="n">unique_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">special_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_element_coords</span><span class="p">[</span><span class="n">special_elements</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># noqa</span>
        <span class="n">unique_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">special_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">special_s_coords</span> <span class="o">=</span> <span class="n">unique_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">special_z_coords</span> <span class="o">=</span> <span class="n">unique_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">s_coords</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">z_coords</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;markers&#39;</span><span class="p">,</span>
                                 <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">special_s_coords</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">special_z_coords</span><span class="p">,</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;markers&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                             <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)))</span>
        <span class="c1"># Decrease the marker size</span>
        <span class="n">marker_size</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># Change this value to adjust marker size</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">marker_size</span><span class="p">))</span>
        <span class="c1"># Set aspect ratio to 1:1</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
            <span class="n">autosize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="mi">1600</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="mi">1600</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="ElementOutput.obspyfy">
<a class="viewcode-back" href="../../../../axikernels.core.handlers.html#axikernels.core.handlers.element_output.ElementOutput.obspyfy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">obspyfy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_station_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># Create obspyfy folder if not existent already</span>
        <span class="n">obspyfy_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_to_elements_output</span> <span class="o">+</span> <span class="s1">&#39;/obspyfied&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">obspyfy_path</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">obspyfy_path</span><span class="p">)</span>
        <span class="n">cat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalogue</span>
        <span class="n">cat</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obspyfy_path</span> <span class="o">+</span> <span class="s1">&#39;/cat.xml&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;QUAKEML&#39;</span><span class="p">)</span>

        <span class="n">stations_file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path_to_station_file</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># noqa</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_inventory</span><span class="p">(</span><span class="n">path_to_station_file</span><span class="p">)</span>
        <span class="n">inv</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obspyfy_path</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">stations_file_name</span> <span class="o">+</span> <span class="s1">&#39;_inv.xml&#39;</span><span class="p">,</span>
                  <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;stationxml&quot;</span><span class="p">)</span>

        <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream_STA</span><span class="p">(</span><span class="n">path_to_station_file</span><span class="p">,</span> <span class="n">channels</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obspyfy_path</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">stations_file_name</span> <span class="o">+</span> <span class="s1">&#39;.mseed&#39;</span><span class="p">,</span>
                     <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;MSEED&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ElementOutput.create_inventory">
<a class="viewcode-back" href="../../../../axikernels.core.handlers.html#axikernels.core.handlers.element_output.ElementOutput.create_inventory">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_inventory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_station_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1">##################</span>
        <span class="c1"># Create Inventory</span>
        <span class="c1">##################</span>

        <span class="n">networks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">station_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">channels_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Get path to where the new inventory will be saved, and coordinates</span>

        <span class="c1"># Create new empty inventory</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="n">Inventory</span><span class="p">(</span>
            <span class="n">networks</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">source</span><span class="o">=</span><span class="s2">&quot;Inventory from axisem STATIONS file&quot;</span><span class="p">)</span>

        <span class="c1"># Open station file</span>
        <span class="n">stations</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path_to_station_file</span><span class="p">,</span>
                    <span class="n">sep</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span>
                    <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;network&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;longitude&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;useless&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;depth&quot;</span><span class="p">],</span>
                    <span class="n">comment</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">))</span>

        <span class="c1"># Iterate over all stations in the stations file</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">stations</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="c1"># Create network if not already existent</span>
            <span class="n">net_exists</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">network</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">network</span><span class="o">.</span><span class="n">code</span> <span class="o">==</span> <span class="n">station</span><span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">]:</span>
                    <span class="n">net_exists</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">net</span> <span class="o">=</span> <span class="n">network</span>
            <span class="k">if</span> <span class="n">net_exists</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">net</span> <span class="o">=</span> <span class="n">Network</span><span class="p">(</span>
                    <span class="n">code</span><span class="o">=</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">],</span>
                    <span class="n">stations</span><span class="o">=</span><span class="p">[])</span>
                <span class="c1"># add new network to inventory</span>
                <span class="n">inv</span><span class="o">.</span><span class="n">networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>

            <span class="c1"># Create station (should be unique!)</span>
            <span class="n">sta</span> <span class="o">=</span> <span class="n">Station</span><span class="p">(</span>
                <span class="n">code</span><span class="o">=</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
                <span class="n">latitude</span><span class="o">=</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">],</span>
                <span class="n">longitude</span><span class="o">=</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">],</span>
                <span class="n">elevation</span><span class="o">=-</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">])</span>
            <span class="n">net</span><span class="o">.</span><span class="n">stations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sta</span><span class="p">)</span>

            <span class="c1"># Create the channels</span>
            <span class="c1"># here we must find in which element group is this station located</span>
            <span class="n">rad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain_Radius</span> <span class="o">-</span> <span class="n">station</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">])</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">])</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rad</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="c1"># get inplane coords</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">sph2cart</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">cart2cyl</span><span class="p">(</span><span class="n">cart_geo2cart_src</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">point</span><span class="p">,</span>
                                               <span class="n">rotation_matrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rotation_matrix</span><span class="p">))</span> <span class="c1"># noqa</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">cart2polar</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">element_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_separate_by_inplane_domain</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1"># noqa</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups</span><span class="p">[</span><span class="n">element_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;detailed_channels&#39;</span><span class="p">]:</span> <span class="c1"># noqa</span>
                <span class="n">cha</span> <span class="o">=</span> <span class="n">Channel</span><span class="p">(</span>
                    <span class="n">code</span><span class="o">=</span><span class="n">channel</span><span class="p">,</span>
                    <span class="n">location_code</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="n">latitude</span><span class="o">=</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">],</span>
                    <span class="n">longitude</span><span class="o">=</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">],</span>
                    <span class="n">elevation</span><span class="o">=-</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">],</span>
                    <span class="n">depth</span><span class="o">=</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">],</span>
                    <span class="n">azimuth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">dip</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">sample_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">sta</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cha</span><span class="p">)</span>

            <span class="c1"># Form the lists that will be used as inputs with read_netcdf</span>
            <span class="c1"># to get the stream of the wavefield data</span>
            <span class="n">networks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">])</span>
            <span class="n">station_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">station</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
            <span class="n">locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  <span class="c1"># Axisem does not use locations</span>
            <span class="n">channels_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;detailed_channels&#39;</span><span class="p">])</span> <span class="c1"># noqa</span>

        <span class="k">return</span> <span class="n">inv</span></div>


<div class="viewcode-block" id="ElementOutput.stream_STA">
<a class="viewcode-back" href="../../../../axikernels.core.handlers.html#axikernels.core.handlers.element_output.ElementOutput.stream_STA">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">stream_STA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_station_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                   <span class="n">channels</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                   <span class="n">time_limits</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes in the path to a station file used for axisem3d</span>
<span class="sd">        and returns a stream with the wavefields computed at all stations</span>

<span class="sd">        Args:</span>
<span class="sd">            path_to_station_file (str): path to station.txt file</span>

<span class="sd">        Returns:</span>
<span class="sd">            obspy.stream: stream</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get time slices from time limits</span>
        <span class="k">if</span> <span class="n">time_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">data_time</span> <span class="o">&gt;=</span> <span class="n">time_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_time</span> <span class="o">&lt;=</span> <span class="n">time_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time_slices</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Open station file</span>
        <span class="n">stations</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path_to_station_file</span><span class="p">,</span>
                    <span class="n">sep</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span>
                    <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;network&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;longitude&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;useless&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;depth&quot;</span><span class="p">],</span>
                    <span class="n">comment</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">))</span>
        <span class="c1"># initiate stream that will hold data</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">stations</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">stalat</span> <span class="o">=</span> <span class="n">station</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">]</span>
            <span class="n">stalon</span> <span class="o">=</span> <span class="n">station</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">]</span>
            <span class="n">stadepth</span> <span class="o">=</span> <span class="n">station</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span>
            <span class="n">starad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain_Radius</span> <span class="o">-</span> <span class="n">stadepth</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">starad</span><span class="p">,</span> <span class="n">stalat</span><span class="p">,</span> <span class="n">stalon</span><span class="p">])</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># get the data at this station (assuming RTZ components)</span>
        <span class="n">wave_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span>
                                   <span class="n">channels</span><span class="o">=</span><span class="n">channels</span><span class="p">,</span>
                                   <span class="n">time_slices</span><span class="o">=</span><span class="n">time_slices</span><span class="p">)</span>
        <span class="c1"># Construct metadata</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
        <span class="n">first_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">first_key</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;data_time&#39;</span><span class="p">]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">data_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_time</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">stations</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">network</span> <span class="o">=</span> <span class="n">station</span><span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">]</span>
            <span class="n">station_name</span> <span class="o">=</span> <span class="n">station</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">chn_index</span><span class="p">,</span> <span class="n">chn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
                <span class="c1"># form the traces at the channel level</span>
                <span class="n">trace</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Trace</span><span class="p">(</span><span class="n">wave_data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">chn_index</span><span class="p">])</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">ntps</span> <span class="o">=</span> <span class="n">npts</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="o">=</span> <span class="n">station_name</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">chn</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="s2">&quot;1970-01-01T00:00:00.0Z&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stream</span></div>


<div class="viewcode-block" id="ElementOutput.stream">
<a class="viewcode-back" href="../../../../axikernels.core.handlers.html#axikernels.core.handlers.element_output.ElementOutput.stream">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
               <span class="n">coord_in_deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
               <span class="n">time_limits</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a stream with the wavefields computed at all stations given the location.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (list): The location of the station in meters and radians/degrees.</span>
<span class="sd">                It should be a list with the following elements:</span>
<span class="sd">                - radial position in meters (float)</span>
<span class="sd">                - latitude in radians/degrees (float)</span>
<span class="sd">                - longitude in radians/degrees (float)</span>
<span class="sd">            coord_in_deg (bool, optional): Specify whether the coordinates are in degrees.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            channels (list, optional): List of wavefield channels to include.</span>
<span class="sd">                Defaults to None, which includes all channels.</span>
<span class="sd">            time_limits (list, optional): Time limits for the data.</span>
<span class="sd">                It should be a list with two elements:</span>
<span class="sd">                - start time in seconds (float)</span>
<span class="sd">                - end time in seconds (float)</span>
<span class="sd">                Defaults to None, which includes all times.</span>

<span class="sd">        Returns:</span>
<span class="sd">            obspy.Stream: A stream containing the wavefields computed at all stations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get time slices from time limits. We assume that all points have the same time axis!!!!</span>
        <span class="n">first_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">first_key</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;data_time&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">time_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">data_time</span> <span class="o">&gt;=</span> <span class="n">time_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data_time</span> <span class="o">&lt;=</span> <span class="n">time_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time_slices</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># In case we receive a point as a vector ...</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

        <span class="c1"># initiate stream that will hold data</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
        <span class="c1"># get the data at this station (assuming RTZ components)</span>
        <span class="n">wave_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span>
                                    <span class="n">channels</span><span class="o">=</span><span class="n">channels</span><span class="p">,</span>
                                    <span class="n">time_slices</span><span class="o">=</span><span class="n">time_slices</span><span class="p">,</span>
                                    <span class="n">in_deg</span><span class="o">=</span><span class="n">coord_in_deg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># Construct metadata</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">data_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_time</span><span class="p">)</span>
            <span class="n">network</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
            <span class="n">station_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">chn_index</span><span class="p">,</span> <span class="n">chn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
                <span class="c1"># form the traces at the channel level</span>
                <span class="n">trace</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Trace</span><span class="p">(</span><span class="n">wave_data</span><span class="p">[</span><span class="n">point_index</span><span class="p">][</span><span class="n">chn_index</span><span class="p">])</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">ntps</span> <span class="o">=</span> <span class="n">npts</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="o">=</span> <span class="n">station_name</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">chn</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="s2">&quot;1970-01-01T00:00:00.0Z&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stream</span></div>


<div class="viewcode-block" id="ElementOutput.load_data">
<a class="viewcode-back" href="../../../../axikernels.core.handlers.html#axikernels.core.handlers.element_output.ElementOutput.load_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">channels</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">time_slices</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">frame</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;geographic&#39;</span><span class="p">,</span>
                  <span class="n">coords</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;spherical&#39;</span><span class="p">,</span> <span class="n">in_deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                  <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="c1"># Only options for coords are geographic+spherical,</span>
        <span class="c1"># geographic+cartesian, source+cylindrical and source+spherical</span>

        <span class="c1"># If we receive only one point as ndarray([a,b,c]) we turn it into</span>
        <span class="c1"># ndarray([[a,b,c]])</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># Make sure the data type of points is floats</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Transforms points to cylindrical coords in source frame</span>
        <span class="n">points</span><span class="p">,</span> <span class="n">inplane_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project_on_inplane</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="n">in_deg</span><span class="p">,</span>
                                                        <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>

        <span class="c1"># Separate inplane points by the element group they are part of</span>
        <span class="n">point_group_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_separate_by_inplane_domain</span><span class="p">(</span><span class="n">inplane_points</span><span class="p">)</span>

        <span class="c1"># Create channel slices and time slices if not given. Look at what</span>
        <span class="c1"># groups are present and make sure that all groups have the needed</span>
        <span class="c1"># channels in the same position</span>
        <span class="k">if</span> <span class="n">time_slices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">element_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;data_time&#39;</span><span class="p">]))</span>

        <span class="c1"># Initialize the final result</span>
        <span class="n">final_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_slices</span><span class="p">)))</span>

        <span class="c1"># Compute the inplane coordinates</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; # Interpolate all groups</span>
<span class="sd">        for group_index, element_group in enumerate(self.element_groups_info):</span>
<span class="sd">            point_index = np.where(group_mapping==group_index)</span>
<span class="sd">            group_points = points[point_index]</span>
<span class="sd">            if len(group_points) != 0:</span>
<span class="sd">                final_result[point_index,:,:] = self.load_data_from_element_group(group_points, element_group,</span>
<span class="sd">                                                                                channel_slices, time_slices) &quot;&quot;&quot;</span>

        <span class="c1"># Interpolate all groups</span>
        <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Loading and interpolating&quot;</span><span class="p">,</span>
                  <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;point&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">group_index</span><span class="p">,</span> <span class="n">element_group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">):</span>
                <span class="c1"># These two lines pick only the points that are in the current</span>
                <span class="c1"># element group</span>
                <span class="n">point_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">point_group_mapping</span> <span class="o">==</span> <span class="n">group_index</span><span class="p">)</span>
                <span class="n">group_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_points</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups</span><span class="p">[</span><span class="n">group_index</span><span class="p">]</span>
                    <span class="n">channel_slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel_slices</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
                    <span class="c1"># create batches at element group level</span>
                    <span class="n">num_batches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_points</span><span class="p">)</span> <span class="o">//</span> <span class="n">batch_size</span>

                    <span class="k">for</span> <span class="n">batch_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_batches</span><span class="p">):</span>
                        <span class="n">point_index_batch</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">point_index</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">batch_index</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">:</span>
                                           <span class="p">(</span><span class="n">batch_index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">batch_size</span><span class="p">],</span>
                        <span class="p">)</span>
                        <span class="n">group_points_batch</span> <span class="o">=</span> <span class="n">group_points</span><span class="p">[</span><span class="n">batch_index</span><span class="o">*</span><span class="n">batch_size</span><span class="p">:</span> <span class="c1"># noqa</span>
                                                          <span class="p">(</span><span class="n">batch_index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">batch_size</span><span class="p">]</span> <span class="c1"># noqa</span>

                        <span class="n">final_result</span><span class="p">[</span><span class="n">point_index_batch</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data_from_element_group</span><span class="p">(</span> <span class="c1"># noqa</span>
                                <span class="n">group_points_batch</span><span class="p">,</span> <span class="n">element_group</span><span class="p">,</span>
                                <span class="n">channel_slices</span><span class="p">,</span> <span class="n">time_slices</span><span class="p">,</span> <span class="n">pbar</span>
                        <span class="p">)</span>
                    <span class="c1"># now compute the remaining group points if any left</span>
                    <span class="k">if</span> <span class="n">num_batches</span><span class="o">*</span><span class="n">batch_size</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_points</span><span class="p">):</span>
                        <span class="n">point_index_batch_residue</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">point_index</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">num_batches</span><span class="o">*</span><span class="n">batch_size</span><span class="p">:],</span>
                        <span class="p">)</span>
                        <span class="n">group_points_batch_residue</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">group_points</span><span class="p">[</span><span class="n">num_batches</span><span class="o">*</span><span class="n">batch_size</span><span class="p">:]</span>
                        <span class="p">)</span>
                        <span class="n">final_result</span><span class="p">[</span><span class="n">point_index_batch_residue</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data_from_element_group</span><span class="p">(</span> <span class="c1"># noqa</span>
                            <span class="n">group_points_batch_residue</span><span class="p">,</span> <span class="n">element_group</span><span class="p">,</span>
                            <span class="n">channel_slices</span><span class="p">,</span> <span class="n">time_slices</span><span class="p">,</span> <span class="n">pbar</span>
                        <span class="p">)</span>

        <span class="k">return</span> <span class="n">final_result</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_separate_by_inplane_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplane_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                    <span class="n">domains</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigns each point in the given ndarray to one of the specified domains</span>
<span class="sd">        based on their polar coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            inplane_points (numpy.ndarray): The ndarray containing points in</span>
<span class="sd">            polar coordinates [radius, theta].</span>
<span class="sd">            domains (list): List of domains specified as [r_min, r_max,</span>
<span class="sd">            theta_min, theta_max].</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: An array containing the assigned domain index for</span>
<span class="sd">            each point. If a point does not fall within any domain, it is</span>
<span class="sd">                        assigned the value -1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">domains</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Then we use as domains the domains defined by the element groups:</span>
            <span class="c1"># Find all the domains available in the outputs</span>
            <span class="n">domains</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">element_group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">element_group</span><span class="p">[</span><span class="s1">&#39;elements&#39;</span><span class="p">][</span><span class="s1">&#39;vertical_range&#39;</span><span class="p">])</span> <span class="c1"># noqa</span>
                <span class="n">theta_min</span><span class="p">,</span> <span class="n">theta_max</span> <span class="o">=</span> <span class="n">element_group</span><span class="p">[</span><span class="s1">&#39;elements&#39;</span><span class="p">][</span><span class="s1">&#39;horizontal_range&#39;</span><span class="p">]</span> <span class="c1"># noqa</span>
                <span class="n">domains</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span><span class="p">,</span> <span class="n">theta_min</span><span class="p">,</span> <span class="n">theta_max</span><span class="p">])</span>

        <span class="c1"># Initialize array to store assigned domains</span>
        <span class="n">group_mapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">inplane_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inplane_points</span><span class="p">):</span>
            <span class="n">radius</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">point</span>
            <span class="c1"># Loop through each domain and check if the point falls within it</span>
            <span class="n">not_in_any_domain</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">domain_idx</span><span class="p">,</span> <span class="n">domain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">domains</span><span class="p">):</span>
                <span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span><span class="p">,</span> <span class="n">theta_min</span><span class="p">,</span> <span class="n">theta_max</span> <span class="o">=</span> <span class="n">domain</span>
                <span class="n">tolerance</span> <span class="o">=</span> <span class="mf">1e-6</span>  <span class="c1"># Tolerance for floating point comparison</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r_min</span> <span class="o">-</span> <span class="n">tolerance</span> <span class="o">&lt;=</span> <span class="n">radius</span> <span class="o">&lt;=</span> <span class="n">r_max</span> <span class="o">+</span> <span class="n">tolerance</span> <span class="ow">and</span>
                    <span class="n">theta_min</span> <span class="o">-</span> <span class="n">tolerance</span> <span class="o">&lt;=</span> <span class="n">theta</span> <span class="o">&lt;=</span> <span class="n">theta_max</span> <span class="o">+</span> <span class="n">tolerance</span> <span class="ow">and</span>
                        <span class="n">not_in_any_domain</span><span class="p">):</span>
                    <span class="c1"># Assign domain index to the point</span>
                    <span class="n">group_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain_idx</span>
                    <span class="n">not_in_any_domain</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>  <span class="c1"># No need to check other domains</span>
            <span class="k">if</span> <span class="n">not_in_any_domain</span><span class="p">:</span>
                <span class="n">group_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">group_mapping</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_group_by_material</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Separate points by SOLID/FLUID. Assumes points are in [rad, lat, lon]</span>
        <span class="c1"># in degrees geographic spherical</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">inplane_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project_on_inplane</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">group_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_separate_by_inplane_domain</span><span class="p">(</span><span class="n">inplane_points</span><span class="p">)</span>
        <span class="n">group_mapping_to_material</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;wavefields&#39;</span><span class="p">][</span><span class="s1">&#39;medium&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;SOLID&#39;</span>
                                        <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups</span><span class="p">]</span>
        <span class="n">material_mapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">group_mapping_to_material</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">group_mapping</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">material_mapping</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_project_on_inplane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">frame</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;geographic&#39;</span><span class="p">,</span>
                            <span class="n">coords</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;spherical&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># points must have shape (n,3) where n is the number of points</span>
        <span class="n">points_copy</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">degrees</span><span class="p">:</span>
            <span class="n">points_copy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">points_copy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>

        <span class="k">if</span> <span class="n">frame</span> <span class="o">==</span> <span class="s1">&#39;geographic&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="o">==</span> <span class="s1">&#39;spherical&#39;</span><span class="p">:</span>
                <span class="n">points_copy</span> <span class="o">=</span> <span class="n">sph2cart_mpmath</span><span class="p">(</span><span class="n">points_copy</span><span class="p">)</span>
            <span class="n">points_copy</span> <span class="o">=</span> <span class="n">cart2cyl_mpmath</span><span class="p">(</span>
                <span class="n">cart_geo2cart_src</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">points_copy</span><span class="p">,</span>
                                  <span class="n">rotation_matrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rotation_matrix</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Convert the string representation to a NumPy array of floats (I think</span>
        <span class="c1"># this was to go from mpmath to numpy format ...)</span>
        <span class="n">points_copy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)))(</span><span class="n">points_copy</span><span class="p">)</span>
        <span class="c1"># We add pi/2 beacause by default cart2polar sets theta to zero along</span>
        <span class="c1"># the s axis, but in the inparam.output theta is set to 0 at the z axis</span>
        <span class="n">inplane_points</span> <span class="o">=</span> <span class="n">cart2polar_mpmath</span><span class="p">(</span><span class="n">points_copy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points_copy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">inplane_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>

        <span class="k">return</span> <span class="n">points_copy</span><span class="p">,</span> <span class="n">inplane_points</span>

<div class="viewcode-block" id="ElementOutput.load_data_from_element_group">
<a class="viewcode-back" href="../../../../axikernels.core.handlers.html#axikernels.core.handlers.element_output.ElementOutput.load_data_from_element_group">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_data_from_element_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">group</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                     <span class="n">channel_slices</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">time_slices</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">pbar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># All points must be from the same element group!!!</span>

        <span class="c1"># Initialize the final result</span>
        <span class="n">final_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">channel_slices</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">time_slices</span><span class="p">)))</span>

        <span class="c1"># Get lagrange order</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;inplane&#39;</span><span class="p">][</span><span class="s1">&#39;GLL_points_one_edge&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="ow">and</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;inplane&#39;</span><span class="p">][</span><span class="s1">&#39;edge_dimension&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;BOTH&#39;</span><span class="p">:</span>
            <span class="n">lagrange_order</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using lagrange order 3.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No implementation for this output type.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;No implementation for this output type.&quot;</span><span class="p">)</span>

        <span class="c1"># Find which points are unique in the inplane domain</span>
        <span class="n">unique_points_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">unique_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="c1"># Some points may have the same s-z coordinates but after</span>
            <span class="c1"># transformations the numerical errors made them different, so we</span>
            <span class="c1"># round the transformed points to decimals decimals</span>
            <span class="n">decimals</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">unique_points_dict</span><span class="p">:</span>
                <span class="n">unique_points_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_points_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">point</span><span class="p">}</span>
                <span class="n">unique_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="n">unique_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unique_points</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Only </span><span class="si">{}% o</span><span class="s1">f the points have unique inplane coords.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_points</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)))</span>

        <span class="c1"># Create element map for the unique points</span>
        <span class="n">element_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;list_element_coords&#39;</span><span class="p">][:,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># Assuming the center point is at index 4</span>
        <span class="n">differences</span> <span class="o">=</span> <span class="n">element_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">unique_points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">differences</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">elements_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Created element map&#39;</span><span class="p">)</span>

        <span class="c1"># Create elements_dict</span>
        <span class="n">elements_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">elements_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">element</span><span class="p">,</span> <span class="n">unique_point</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">elements_map</span><span class="p">,</span> <span class="n">unique_points</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">unique_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">unique_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements_dict</span><span class="p">:</span>
                <span class="n">elements_dict</span><span class="p">[</span><span class="n">element</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_points_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">elements_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">unique_points_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]}</span>
                <span class="n">elements_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Only </span><span class="si">{}% o</span><span class="s1">f the elements need to be loaded.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">elements_list</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_points</span><span class="p">))))</span>

        <span class="c1"># Create a file map and a nag map for elements</span>
        <span class="n">file_element_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;elements_index_limits&#39;</span><span class="p">],</span> <span class="n">elements_list</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">nag_map</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements_list</span><span class="p">:</span>
            <span class="n">nag_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;list_element_na&#39;</span><span class="p">][</span><span class="n">element</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Created file and nag map&#39;</span><span class="p">)</span>

        <span class="c1"># Create file dict</span>
        <span class="n">main_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">file_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">file</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">nag</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">file_element_map</span><span class="p">,</span> <span class="n">elements_list</span><span class="p">,</span> <span class="n">nag_map</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">main_dict</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nag</span> <span class="ow">in</span> <span class="n">main_dict</span><span class="p">[</span><span class="n">file</span><span class="p">]:</span>
                    <span class="n">main_dict</span><span class="p">[</span><span class="n">file</span><span class="p">][</span><span class="n">nag</span><span class="p">][</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="n">elements_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">main_dict</span><span class="p">[</span><span class="n">file</span><span class="p">][</span><span class="n">nag</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">element</span><span class="p">:</span> <span class="n">elements_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">main_dict</span><span class="p">[</span><span class="n">file</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">nag</span><span class="p">:</span> <span class="p">{</span><span class="n">element</span><span class="p">:</span> <span class="n">elements_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]}}</span>
                <span class="n">file_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Created main dictionary&#39;</span><span class="p">)</span>

        <span class="c1"># Go file by file, nag by nag</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;---START LOADING---&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">main_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">nag</span> <span class="ow">in</span> <span class="n">main_dict</span><span class="p">[</span><span class="n">file</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># Grab the indices of the elements in the self.list_element_coords</span>
                <span class="n">elements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">main_dict</span><span class="p">[</span><span class="n">file</span><span class="p">][</span><span class="n">nag</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">elements_in_file_nag</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;list_element_na&#39;</span><span class="p">][</span><span class="n">element</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">]</span>

                <span class="c1"># Find problematic elements</span>
                <span class="n">problematic_elements</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># contains the indices of the problematic elements in the local element list</span>
                <span class="n">proof</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;list_element_coords&#39;</span><span class="p">][</span><span class="n">elements</span><span class="p">]):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">element</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">element</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="n">cart2polar</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">points</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">theta</span> <span class="o">=</span> <span class="n">points</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">r_grid</span><span class="p">,</span> <span class="n">theta_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
                    <span class="n">expected_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">r_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">theta_grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">expected_points</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
                        <span class="n">problematic_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                        <span class="n">proof</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
                <span class="c1">#self.plot_mesh(np.array(elements)[problematic_elements])</span>

                <span class="c1"># Read the data from the file</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Loading raw data.&#39;</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;files&#39;</span><span class="p">][</span><span class="n">file</span><span class="p">][</span><span class="s1">&#39;data_wave__NaG=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">nag</span><span class="p">][</span><span class="n">elements_in_file_nag</span><span class="p">][:,:,:,</span><span class="n">channel_slices</span><span class="p">,</span><span class="n">time_slices</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

                <span class="c1"># Data expansion for unique inplane points</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Expanding data to all unique inplane points.&#39;</span><span class="p">)</span>
                <span class="n">in_element_repetitions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inplane_points</span><span class="p">)</span> <span class="k">for</span> <span class="n">inplane_points</span> <span class="ow">in</span> <span class="n">main_dict</span><span class="p">[</span><span class="n">file</span><span class="p">][</span><span class="n">nag</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
                <span class="c1"># may delete later</span>
                <span class="n">map_of_problematique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">))</span>
                <span class="n">map_of_problematique</span><span class="p">[</span><span class="n">problematic_elements</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">in_element_repetitions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># This is the case where in each element there is only one</span>
                    <span class="c1"># inplane point where we need to run the inplane</span>
                    <span class="c1"># interpolation</span>
                    <span class="n">expanded_data</span> <span class="o">=</span> <span class="n">data</span> <span class="c1"># no expansion occurs in this case</span>
                    <span class="n">expanded_map_of_problematique</span> <span class="o">=</span> <span class="n">map_of_problematique</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If there are multiple unique inplane points in some</span>
                    <span class="c1"># elements, we need to expand the data</span>
                    <span class="n">final_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">in_element_repetitions</span><span class="p">)),)</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">expanded_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">final_shape</span><span class="p">)</span>
                    <span class="n">expanded_map_of_problematique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">final_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">expanded_index</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">repetitions</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">in_element_repetitions</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">repetitions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">expanded_data</span><span class="p">[</span><span class="n">expanded_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                            <span class="n">expanded_map_of_problematique</span><span class="p">[</span><span class="n">expanded_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_of_problematique</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                            <span class="n">expanded_index</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repetitions</span><span class="p">):</span>
                                <span class="n">expanded_data</span><span class="p">[</span><span class="n">expanded_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                                <span class="n">expanded_map_of_problematique</span><span class="p">[</span><span class="n">expanded_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_of_problematique</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                                <span class="n">expanded_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">map_of_problematique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">expanded_map_of_problematique</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Find the inplane coords for each element</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Get unique inplane coords&#39;</span><span class="p">)</span>
                <span class="n">inplane_coords</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sub_dict</span> <span class="ow">in</span> <span class="n">main_dict</span><span class="p">[</span><span class="n">file</span><span class="p">][</span><span class="n">nag</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sub_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">inplane_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

                <span class="c1"># Transform to polar coords</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">inplane_coords</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="n">inplane_coords</span> <span class="o">=</span> <span class="n">cart2polar</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

                <span class="c1"># Find the r and theta vectors for each element and construct</span>
                <span class="c1"># lagrange interpolation matrix</span>

                <span class="c1"># Expand coords of element GLL points to unique inplane points</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Expand element coords.&#39;</span><span class="p">)</span>
                <span class="n">points_of_interest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;list_element_coords&#39;</span><span class="p">][</span><span class="n">elements</span><span class="p">][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],:]</span>
                <span class="n">final_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">in_element_repetitions</span><span class="p">)),)</span> <span class="o">+</span>  <span class="n">points_of_interest</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">expanded_points_of_interest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">final_shape</span><span class="p">)</span>
                <span class="n">expanded_index</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">repetitions</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">in_element_repetitions</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">repetitions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">expanded_points_of_interest</span><span class="p">[</span><span class="n">expanded_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">points_of_interest</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                        <span class="n">expanded_index</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repetitions</span><span class="p">):</span>
                            <span class="n">expanded_points_of_interest</span><span class="p">[</span><span class="n">expanded_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">points_of_interest</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                            <span class="n">expanded_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">points_of_interest</span> <span class="o">=</span> <span class="n">expanded_points_of_interest</span>
                <span class="c1"># remove the points of interest located in problematique elements</span>
                <span class="n">points_of_interest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">points_of_interest</span><span class="p">,</span> <span class="n">map_of_problematique</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">good_inplane_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">inplane_coords</span><span class="p">,</span> <span class="n">map_of_problematique</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">original_shape</span> <span class="o">=</span> <span class="n">points_of_interest</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">points_of_interest</span> <span class="o">=</span> <span class="n">points_of_interest</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">points_of_interest</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">points_of_interest</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">points_of_interest</span> <span class="o">=</span> <span class="n">cart2polar</span><span class="p">(</span><span class="n">points_of_interest</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">points_of_interest</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
                <span class="n">GLL_rads</span> <span class="o">=</span> <span class="n">points_of_interest</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">GLL_thetas</span> <span class="o">=</span> <span class="n">points_of_interest</span><span class="p">[:,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="c1"># Compute interpolation weights (LIM)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Compute LIM&#39;</span><span class="p">)</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lagrange</span><span class="p">(</span><span class="n">good_inplane_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">GLL_rads</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">lagrange_order</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lagrange_order</span><span class="p">)])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="n">ltheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lagrange</span><span class="p">(</span><span class="n">good_inplane_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">GLL_thetas</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">lagrange_order</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lagrange_order</span><span class="p">)])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="n">LIM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">ltheta_i</span><span class="p">,</span> <span class="n">lr_i</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">ltheta_i</span><span class="p">,</span> <span class="n">lr_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ltheta</span><span class="p">,</span> <span class="n">lr</span><span class="p">)])</span>

                <span class="c1"># Manually add back into LIM some improvised weights at the</span>
                <span class="c1"># locations within map_of_problematique</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">LIM</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">LIM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">LIM</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">LIM</span> <span class="o">=</span> <span class="n">LIM</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">LIM</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">map_of_problematique</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="n">LIM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">LIM</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">map_of_problematique</span><span class="p">:</span>
                        <span class="n">LIM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">LIM</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Interpolate</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Inplane interpolate&#39;</span><span class="p">)</span>
                <span class="n">inplane_interpolated_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">expanded_data</span> <span class="o">*</span> <span class="n">LIM</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

                <span class="c1"># Add Fourier Coefficients</span>
                <span class="n">inplane_point_repetitions</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">inplane_points</span> <span class="ow">in</span> <span class="n">main_dict</span><span class="p">[</span><span class="n">file</span><span class="p">][</span><span class="n">nag</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">azimuthal_points</span> <span class="ow">in</span> <span class="n">inplane_points</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="n">inplane_point_repetitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">azimuthal_points</span><span class="p">))</span>

                <span class="c1"># expand to point level</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Expanding data to points&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">inplane_point_repetitions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">expanded_interpolated_data</span> <span class="o">=</span> <span class="n">inplane_interpolated_data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">final_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inplane_point_repetitions</span><span class="p">)),)</span> <span class="o">+</span> <span class="n">inplane_interpolated_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">expanded_interpolated_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">final_shape</span><span class="p">)</span>
                    <span class="n">expanded_index</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">repetitions</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inplane_point_repetitions</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">repetitions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">expanded_interpolated_data</span><span class="p">[</span><span class="n">expanded_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">inplane_interpolated_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                            <span class="n">expanded_index</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repetitions</span><span class="p">):</span>
                                <span class="n">expanded_interpolated_data</span><span class="p">[</span><span class="n">expanded_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">inplane_interpolated_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                                <span class="n">expanded_index</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># Fourier interpolation</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Fourier interpolation&#39;</span><span class="p">)</span>
                <span class="c1"># Get the phis</span>
                <span class="n">phi</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">name_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sub_dict</span> <span class="ow">in</span> <span class="n">main_dict</span><span class="p">[</span><span class="n">file</span><span class="p">][</span><span class="n">nag</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">sub_sub_dict</span> <span class="ow">in</span> <span class="n">sub_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sub_sub_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">name_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                            <span class="n">phi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_sub_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
                <span class="c1"># Set complex type</span>
                <span class="n">complex_type</span> <span class="o">=</span> <span class="n">expanded_interpolated_data</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">expanded_interpolated_data</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
                <span class="n">max_fourier_order</span> <span class="o">=</span> <span class="n">nag</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">expanded_interpolated_data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_fourier_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_type</span><span class="p">)</span>
                    <span class="c1"># Real part</span>
                    <span class="n">coeff</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">expanded_interpolated_data</span><span class="p">[:,</span><span class="n">order</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,:,:]</span>
                    <span class="c1"># Complex part of Fourier coefficients</span>
                    <span class="k">if</span> <span class="n">order</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">nag</span><span class="p">:</span>  <span class="c1"># Check for Nyquist</span>
                        <span class="n">coeff</span><span class="o">.</span><span class="n">imag</span> <span class="o">+=</span> <span class="n">expanded_interpolated_data</span><span class="p">[:,</span><span class="n">order</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,:,:]</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">order</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">coeff</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

                <span class="c1"># Place the result in the final result ndarray</span>
                <span class="n">final_result</span><span class="p">[</span><span class="n">name_list</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">result</span>

                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">name_list</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">final_result</span></div>


<div class="viewcode-block" id="ElementOutput.load_data_on_mesh">
<a class="viewcode-back" href="../../../../axikernels.core.handlers.html#axikernels.core.handlers.element_output.ElementOutput.load_data_on_mesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_data_on_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">:</span><span class="n">Mesh</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">time_slices</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load data on a mesh.</span>

<span class="sd">        Args:</span>
<span class="sd">            mesh (Mesh): The mesh object to load data onto.</span>
<span class="sd">            channels (list): List of channels to load data for.</span>
<span class="sd">            time_slices (list): List of time slices to load data for.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Data loaded onto the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplane_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_slices</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="s1">&#39;geographic&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="s1">&#39;spherical&#39;</span><span class="p">,</span> <span class="n">in_deg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">channels</span><span class="o">=</span><span class="n">channels</span><span class="p">,</span> <span class="n">time_slices</span><span class="o">=</span><span class="n">time_slices</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">],</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
            <span class="n">inplane_field</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">inplane_field</span></div>


<div class="viewcode-block" id="ElementOutput.animation">
<a class="viewcode-back" href="../../../../axikernels.core.handlers.html#axikernels.core.handlers.element_output.ElementOutput.animation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">animation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_location</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">station_location</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;UZ&#39;</span><span class="p">],</span>
                          <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;video&#39;</span><span class="p">,</span> <span class="n">video_duration</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">frame_rate</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                          <span class="n">resolution</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">domains</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">lower_range</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">upper_range</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.9999</span><span class="p">,</span>
                          <span class="n">paralel_processing</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mesh_type</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;slice&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate an animation representing seismic data on a slice frame.</span>

<span class="sd">        Args:</span>
<span class="sd">            source_location (list): The coordinates [rad, lat, lon] of the seismic source in the Earth frame in radians.</span>
<span class="sd">            station_location (list): The coordinates [rad, lat, lon] of the station location in the Earth frame in radians.</span>
<span class="sd">            name (str, optional): The name of the output video file. Defaults to &#39;video&#39;.</span>
<span class="sd">            video_duration (int, optional): The duration of the video in seconds. Defaults to 20.</span>
<span class="sd">            frame_rate (int, optional): The number of frames per second in the video. Defaults to 10.</span>
<span class="sd">            resolution (int, optional): The resolution of the slice mesh. Defaults to 100.</span>
<span class="sd">            R_min (float, optional): The minimum radius for data inclusion. Defaults to 0.</span>
<span class="sd">            R_max (float, optional): The maximum radius for data inclusion. Defaults to 6371000.</span>
<span class="sd">            lower_range (float, optional): The lower percentile range for the colorbar intensity. Defaults to 0.5.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create default domains if None were given</span>
        <span class="k">if</span> <span class="n">domains</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domains</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">element_group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">element_group</span><span class="p">[</span><span class="s1">&#39;elements&#39;</span><span class="p">][</span><span class="s1">&#39;vertical_range&#39;</span><span class="p">])</span>
                <span class="n">domains</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">])</span>
        <span class="n">domains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">domains</span><span class="p">)</span>

        <span class="c1"># Create source and station if none were given</span>
        <span class="n">R_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">domains</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">R_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">domains</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">source_location</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">station_location</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">source_location</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R_max</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">station_location</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R_max</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">30</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">source_location</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">source_location</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">station_location</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">station_location</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Get time slices from frame rate and video_duration assuming that the</span>
        <span class="c1"># video will include the entire time axis. We also assume that each</span>
        <span class="c1"># element group that will be plotted has the same time axis</span>
        <span class="c1"># Check if all time axes are the same</span>
        <span class="n">data_time_arrays</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;data_time&#39;</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">]</span>
        <span class="n">all_data_time_same</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">data_time_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">data_time_arrays</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_data_time_same</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Not all element groups have the same time axis.&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
        <span class="n">data_time</span> <span class="o">=</span> <span class="n">data_time_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">no_frames</span> <span class="o">=</span> <span class="n">frame_rate</span><span class="o">*</span><span class="n">video_duration</span>
        <span class="n">time_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_time</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">no_frames</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Load the data</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Loading data&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh_type</span> <span class="o">==</span> <span class="s1">&#39;slice&#39;</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">SliceMesh</span><span class="p">(</span><span class="n">point1</span><span class="o">=</span><span class="n">source_location</span><span class="p">,</span>
                             <span class="n">point2</span><span class="o">=</span><span class="n">station_location</span><span class="p">,</span>
                             <span class="n">domains</span><span class="o">=</span><span class="n">domains</span><span class="p">,</span>
                             <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">)</span>
        <span class="n">inplane_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data_on_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">time_slices</span><span class="p">)</span>

        <span class="c1"># Create animation</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Create animation&#39;</span><span class="p">)</span>
        <span class="c1"># Create a figure and axis</span>
        <span class="n">num_subplots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
        <span class="n">num_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_subplots</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">num_cols</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">num_subplots</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="c1"># Make a cbar</span>
        <span class="n">cbar_min</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cbar_max</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">channel_slice</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                    <span class="n">cbar_min_temp</span><span class="p">,</span> <span class="n">cbar_max_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">inplane_field</span><span class="p">[:,:,</span><span class="n">channel_slice</span><span class="p">,:])),</span> <span class="n">lower_range</span><span class="p">,</span> <span class="n">upper_range</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">cbar_min_temp</span><span class="p">,</span> <span class="n">cbar_max_temp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
            <span class="n">cbar_min</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cbar_min_temp</span><span class="p">)</span>
            <span class="n">cbar_max</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cbar_max_temp</span><span class="p">)</span>

        <span class="c1"># Set font size</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">})</span>

        <span class="c1"># Create a figure and axes</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>

        <span class="c1"># Replace -inf values with small values for plotting purposes only Also</span>
        <span class="c1"># set to nan all values outside of the R_max circle and inside the R_min</span>
        <span class="c1"># circle</span>
        <span class="n">processed_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">inplane_field</span><span class="p">))</span>
        <span class="n">processed_values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">processed_values</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cbar_min</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># Replace values outside the circle with NaN</span>
        <span class="n">distance_from_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">inplane_DIM1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">mesh</span><span class="o">.</span><span class="n">inplane_DIM2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Find out which discontinuities (from base model) appear in the animation</span>
        <span class="n">discontinuities_to_plot</span> <span class="o">=</span> <span class="p">[]</span><span class="c1">#[discontinuity for discontinuity in self.base_model[&#39;DISCONTINUITIES&#39;] if R_min &lt;= discontinuity &lt;= R_max]</span>
        <span class="k">for</span> <span class="n">channel_slice</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">axes</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">channel_slice</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
                <span class="n">contour</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">inplane_DIM1</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">inplane_DIM2</span><span class="p">,</span>
                                      <span class="n">processed_values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channel_slice</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">cbar_min</span><span class="p">[</span><span class="n">channel_slice</span><span class="p">],</span> <span class="c1"># noqa</span>
                                                         <span class="n">cbar_max</span><span class="p">[</span><span class="n">channel_slice</span><span class="p">],</span> <span class="mi">100</span><span class="p">),</span> <span class="c1"># noqa</span>
                                      <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdBu_r&#39;</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">base1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span>
                                                                   <span class="n">mesh</span><span class="o">.</span><span class="n">base2</span><span class="p">))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">base1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span>
                                                                   <span class="n">mesh</span><span class="o">.</span><span class="n">base2</span><span class="p">))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">channels</span><span class="p">[</span><span class="n">channel_slice</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="c1"># Create a colorbar for each subplot</span>
                <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="mf">0.046</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.04</span><span class="p">)</span>
                <span class="n">cbar_ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">cbar_min</span><span class="p">[</span><span class="n">channel_slice</span><span class="p">],</span>
                                         <span class="n">cbar_max</span><span class="p">[</span><span class="n">channel_slice</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>  <span class="c1"># Remove x ticks</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>  <span class="c1"># Remove y ticks</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;Log10(Amplitude)&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">channel_slice</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">axes</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">channel_slice</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
                    <span class="c1"># Color everything outside the circle in white</span>
                    <span class="n">outside_circle</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">R_max</span><span class="p">,</span>
                                                <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">outside_circle</span><span class="p">)</span>

                    <span class="n">contour</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">inplane_DIM1</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">inplane_DIM2</span><span class="p">,</span>
                                          <span class="n">processed_values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channel_slice</span><span class="p">,</span> <span class="n">frame</span><span class="p">],</span> <span class="c1"># noqa</span>
                                          <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">cbar_min</span><span class="p">[</span><span class="n">channel_slice</span><span class="p">],</span> <span class="c1"># noqa</span>
                                                             <span class="n">cbar_max</span><span class="p">[</span><span class="n">channel_slice</span><span class="p">],</span> <span class="mi">100</span><span class="p">),</span> <span class="c1"># noqa</span>
                                          <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdBu_r&#39;</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">base1</span><span class="p">),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">base2</span><span class="p">))</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">base1</span><span class="p">),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">point2</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">base2</span><span class="p">))</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">channels</span><span class="p">[</span><span class="n">channel_slice</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>  <span class="c1"># Remove x ticks</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>  <span class="c1"># Remove y ticks</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                    <span class="c1"># Add a circle with radius R to the plot</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">discontinuities_to_plot</span><span class="p">:</span>
                        <span class="n">circle</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span>
                                            <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                                            <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">frame</span> <span class="o">/</span> <span class="n">no_frames</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">contour</span>

        <span class="c1"># Adjust spacing between subplots</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                            <span class="n">wspace</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

        <span class="c1"># Create the animation</span>
        <span class="n">ani</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span>
                                      <span class="n">frames</span><span class="o">=</span><span class="n">video_duration</span> <span class="o">*</span> <span class="n">frame_rate</span><span class="p">,</span>
                                      <span class="n">interval</span><span class="o">=</span><span class="mf">1e3</span> <span class="o">/</span> <span class="n">frame_rate</span><span class="p">)</span>
        <span class="n">ani</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_to_elements_output</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_animation.mp4&#39;</span><span class="p">,</span>
                 <span class="n">writer</span><span class="o">=</span><span class="s1">&#39;ffmpeg&#39;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_point_not_in_output_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># The point must be given as [rad, lat, lon] in radians and in the</span>
        <span class="c1"># geographical frame and spherical coords</span>

        <span class="c1"># Transfrom point into spherical coords in the source frame</span>
        <span class="n">rad</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cart2sph</span><span class="p">(</span><span class="n">cart_geo2cart_src</span><span class="p">(</span><span class="n">sph2cart</span><span class="p">(</span><span class="n">point</span><span class="p">),</span>
                                                 <span class="n">rotation_matrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rotation_matrix</span><span class="p">))</span> <span class="c1"># noqa</span>
        <span class="c1"># In the inparam.output the angle for the horizontal range is actually</span>
        <span class="c1"># the colatitude in the source frame therefore we must transform the</span>
        <span class="c1"># latitude to colatitude</span>
        <span class="n">colat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">lat</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertical_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rad</span> <span class="ow">or</span> <span class="n">rad</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertical_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> \
                <span class="ow">or</span> <span class="n">colat</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizontal_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">colat</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizontal_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># noqa</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_element_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_group_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads a folder that contains the element output files from Axisem3D</span>
<span class="sd">        and outputs the metadata needed to access any data point from the mesh.</span>

<span class="sd">        Returns:</span>
<span class="sd">            na_grid (numpy array): A 1D array that contains all &quot;Nr&quot;s used in</span>
<span class="sd">                                the Fourier expansions in the D domain.</span>
<span class="sd">            data_time (np array): Global time steps of the simulation.</span>
<span class="sd">            list_element_na (np array): For each element, it gives a 1D array</span>
<span class="sd">                                        that contains:</span>
<span class="sd">                                        1. Element tag in the mesh</span>
<span class="sd">                                        2. Actual &quot;Nr&quot;</span>
<span class="sd">                                        3. Stored &quot;Nr&quot; (in case you didn&#39;t want</span>
<span class="sd">                                        to store</span>
<span class="sd">                                        all the Nrs)</span>
<span class="sd">                                        4. Element index in the data (local)</span>
<span class="sd">                                        5. Element index in the data (global)</span>
<span class="sd">            list_element_coords (np array): For each element, for each grid</span>
<span class="sd">                                            point, gives the coordinates in</span>
<span class="sd">                                            the D domain as (s, z).</span>
<span class="sd">            dict_list_element (dict): Lists of element tags arranged by Nr in</span>
<span class="sd">            the dict.</span>
<span class="sd">            nc_files (list): List of opened netCDF files containing the element</span>
<span class="sd">            output data.</span>
<span class="sd">            elements_index_limits (list): List of element index limits for each</span>
<span class="sd">            netCDF file.</span>
<span class="sd">            detailed_channels (list): List of detailed channel names.</span>

<span class="sd">        Note:</span>
<span class="sd">            This method assumes that the element output files are stored in the</span>
<span class="sd">            `path_to_elements_output` directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># open files</span>
        <span class="c1"># filenames (sorted correctly)</span>
        <span class="n">path_to_element_group</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_to_elements_output</span><span class="p">,</span>
                                             <span class="n">element_group_name</span><span class="p">)</span>
        <span class="n">nc_fnames</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path_to_element_group</span><span class="p">)</span> <span class="k">if</span>
                            <span class="s1">&#39;axisem3d_synthetics.nc&#39;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">])</span>

        <span class="c1"># open files</span>
        <span class="n">nc_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nc_fname</span> <span class="ow">in</span> <span class="n">nc_fnames</span><span class="p">:</span>
            <span class="n">nc_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_to_element_group</span><span class="p">,</span>
                                                         <span class="n">nc_fname</span><span class="p">)))</span>

        <span class="c1"># Variables that are the same in the datasets</span>
        <span class="c1"># Read Na grid (all azimuthal dimensions)</span>
        <span class="n">na_grid</span> <span class="o">=</span> <span class="n">nc_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data_vars</span><span class="p">[</span><span class="s1">&#39;list_na_grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Read time</span>
        <span class="n">data_time</span> <span class="o">=</span> <span class="n">nc_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data_vars</span><span class="p">[</span><span class="s1">&#39;data_time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># variables to be concatenated over the datasets minus the data itself</span>
        <span class="c1"># define empty lists of xarray.DataArray objects</span>
        <span class="n">xda_list_element_na</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">xda_list_element_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dict_xda_list_element</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">detailed_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">str_byte</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">for</span>
                             <span class="n">str_byte</span> <span class="ow">in</span> <span class="n">nc_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">list_channel</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
        <span class="n">elements_index_limits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">index_limit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># dict_xda_data_wave = {}</span>
        <span class="k">for</span> <span class="n">nag</span> <span class="ow">in</span> <span class="n">na_grid</span><span class="p">:</span>
            <span class="n">dict_xda_list_element</span><span class="p">[</span><span class="n">nag</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop over nc files</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">nc_file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nc_files</span><span class="p">):</span>
            <span class="c1"># append DataArrays</span>
            <span class="n">index_limit</span> <span class="o">+=</span> <span class="n">nc_file</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;dim_element&#39;</span><span class="p">]</span>
            <span class="n">elements_index_limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_limit</span><span class="p">)</span>
            <span class="n">xda_list_element_na</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nc_file</span><span class="o">.</span><span class="n">data_vars</span><span class="p">[</span><span class="s1">&#39;list_element_na&#39;</span><span class="p">])</span>
            <span class="n">xda_list_element_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nc_file</span><span class="o">.</span><span class="n">data_vars</span><span class="p">[</span><span class="s1">&#39;list_element_coords&#39;</span><span class="p">])</span> <span class="c1"># noqa</span>
            <span class="k">for</span> <span class="n">nag</span> <span class="ow">in</span> <span class="n">na_grid</span><span class="p">:</span>
                <span class="n">dict_xda_list_element</span><span class="p">[</span><span class="n">nag</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nc_file</span><span class="o">.</span><span class="n">data_vars</span><span class="p">[</span><span class="s1">&#39;list_element__NaG=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">nag</span><span class="p">])</span> <span class="c1"># noqa</span>

        <span class="c1"># concat xarray.DataArray</span>
        <span class="n">xda_list_element_na</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">xda_list_element_na</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;dim_element&#39;</span><span class="p">)</span>
        <span class="n">xda_list_element_coords</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">xda_list_element_coords</span><span class="p">,</span>
                                            <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;dim_element&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nag</span> <span class="ow">in</span> <span class="n">na_grid</span><span class="p">:</span>
            <span class="n">dict_xda_list_element</span><span class="p">[</span><span class="n">nag</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dict_xda_list_element</span><span class="p">[</span><span class="n">nag</span><span class="p">],</span>
                                                   <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;dim_element__NaG=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">nag</span><span class="p">)</span> <span class="c1"># noqa</span>

        <span class="c1"># read data to numpy.ndarray</span>
        <span class="n">list_element_na</span> <span class="o">=</span> <span class="n">xda_list_element_na</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">list_element_coords</span> <span class="o">=</span> <span class="n">xda_list_element_coords</span><span class="o">.</span><span class="n">values</span>
        <span class="n">dict_list_element</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">nag</span> <span class="ow">in</span> <span class="n">na_grid</span><span class="p">:</span>
            <span class="n">dict_list_element</span><span class="p">[</span><span class="n">nag</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_xda_list_element</span><span class="p">[</span><span class="n">nag</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># noqa</span>

        <span class="c1"># return: Here we return the files only because in this format they are</span>
        <span class="c1"># not being loaded into RAM Since these files are huge we prefer to</span>
        <span class="c1"># load into ram only the file where the data that we want is located</span>
        <span class="c1"># and then close the file.</span>
        <span class="k">return</span> <span class="n">na_grid</span><span class="p">,</span> <span class="n">data_time</span><span class="p">,</span> <span class="n">list_element_na</span><span class="p">,</span> \
            <span class="n">list_element_coords</span><span class="p">,</span> <span class="n">dict_list_element</span><span class="p">,</span> \
            <span class="n">nc_files</span><span class="p">,</span> <span class="n">elements_index_limits</span><span class="p">,</span> \
            <span class="n">detailed_channels</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_lagrange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluation_points</span><span class="p">,</span> <span class="n">GLL_points</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Lagrange function implementation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">*=</span> <span class="p">(</span><span class="n">evaluation_points</span> <span class="o">-</span> <span class="n">GLL_points</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">/</span> \
                                 <span class="p">(</span><span class="n">GLL_points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">GLL_points</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">w</span><span class="p">:</span>
                        <span class="c1"># A warning occurred, print it along with the traceback</span>
                        <span class="n">warning</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: </span><span class="si">{</span><span class="n">warning</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="c1"># In case of any exception, print the error message</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">percentage_min</span><span class="p">,</span> <span class="n">percentage_max</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the smallest value in the array based on the given percentage.</span>

<span class="sd">        Args:</span>
<span class="sd">            arr (ndarray): The input array.</span>
<span class="sd">            percentage (float): The percentage of values to consider.</span>

<span class="sd">        Returns:</span>
<span class="sd">            smallest_value (float or None): The smallest value based on the</span>
<span class="sd">            given percentage, or None if the array is empty or contains no</span>
<span class="sd">            finite values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Flatten the array to a 1D array</span>
        <span class="n">flattened</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">arr</span><span class="p">)]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flattened</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Sort the flattened array in ascending order</span>
        <span class="n">sorted_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">flattened</span><span class="p">)</span>

        <span class="c1"># Compute the index that corresponds to percentage of the values</span>
        <span class="n">percentile_index_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">)</span> <span class="o">*</span> <span class="n">percentage_min</span><span class="p">)</span>
        <span class="n">percentile_index_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">)</span> <span class="o">*</span> <span class="n">percentage_max</span><span class="p">)</span>

        <span class="c1"># Get the value at the computed index</span>
        <span class="n">smallest_value</span> <span class="o">=</span> <span class="n">sorted_arr</span><span class="p">[</span><span class="n">percentile_index_min</span><span class="p">]</span>
        <span class="n">biggest_value</span> <span class="o">=</span> <span class="n">sorted_arr</span><span class="p">[</span><span class="n">percentile_index_max</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">smallest_value</span><span class="p">,</span> <span class="n">biggest_value</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_channel_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
        <span class="c1"># Get channel slices from channels</span>
        <span class="n">detailed_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;metadata&#39;</span><span class="p">][</span><span class="s1">&#39;detailed_channels&#39;</span><span class="p">]</span> <span class="c1"># noqa</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">ch</span> <span class="ow">in</span> <span class="n">detailed_channels</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">):</span> <span class="c1"># noqa</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">detailed_channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_elements</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;wavefields&#39;</span><span class="p">][</span><span class="s1">&#39;channels&#39;</span><span class="p">])):</span> <span class="c1"># noqa</span>
                <span class="c1"># Filter by channel chosen</span>
                <span class="n">channel_slices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                    <span class="n">channel_slices</span> <span class="o">+=</span> <span class="p">[</span>
                        <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">detailed_channels</span><span class="p">)</span> <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="c1"># noqa</span>
                    <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Only the following channels exist: &#39;</span> <span class="o">+</span>
                                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_groups_info</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="s1">&#39;wavefields&#39;</span><span class="p">][</span><span class="s1">&#39;channels&#39;</span><span class="p">]))</span> <span class="c1"># noqa</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">channel_slices</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">channel_slices</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if all elements in list1 can be found in list2.</span>

<span class="sd">        Args:</span>
<span class="sd">            list1 (list): The first list.</span>
<span class="sd">            list2 (list): The second list.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if all elements in list1 are found in list2, False</span>
<span class="sd">            otherwise.</span>
<span class="sd">            list: List of elements from list1 that are not found in list2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">missing_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">element</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">list1</span>
                            <span class="k">if</span> <span class="n">element</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_elements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_material_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                <span class="n">material_property</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Load bm properties</span>
        <span class="c1"># assume axisem type bm for now</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">[</span><span class="s1">&#39;DATA&#39;</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_model</span><span class="p">[</span><span class="s1">&#39;DATA&#39;</span><span class="p">][</span><span class="n">material_property</span><span class="p">])</span>
        <span class="n">interpolation_function</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">radii</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
        <span class="n">base_model</span> <span class="o">=</span> <span class="n">interpolation_function</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">v3d_model_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_to_simulation</span><span class="p">,</span> <span class="s1">&#39;input/S362ANI_percent.nc&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">v3d_model_filepath</span><span class="p">)</span> <span class="ow">and</span>
            <span class="p">(</span><span class="n">material_property</span> <span class="o">==</span> <span class="s1">&#39;vs&#39;</span> <span class="ow">or</span> <span class="n">material_property</span> <span class="o">==</span> <span class="s1">&#39;vp&#39;</span><span class="p">)):</span>
            <span class="c1"># Load 3d values</span>
            <span class="n">model_3d</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">v3d_model_filepath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="c1"># Get the depth, latitude, and longitude arrays</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="n">model_3d</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">][:]</span>
            <span class="n">radii</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6371</span> <span class="o">-</span> <span class="n">depth</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e3</span>
            <span class="n">latitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">model_3d</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">][:])</span>
            <span class="n">longitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">model_3d</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">][:])</span>

            <span class="c1"># Get the data</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">model_3d</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;dvs&#39;</span><span class="p">][:]</span>
            <span class="n">perturbation</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                <span class="n">perturbation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extrapolate_3d</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">radii</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
            <span class="n">perturbation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">perturbation</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">material_property</span> <span class="o">==</span> <span class="s1">&#39;vs&#39;</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="mf">0.1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="mf">0.1</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">perturbation</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span> <span class="o">*</span> <span class="n">base_model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">base_model</span>

        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extrapolate_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ax3</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># Create interp1d objects for each dimension</span>
        <span class="n">depth_interpolator</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>
        <span class="n">latitude_interpolator</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">depth_interpolator</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>
        <span class="n">longitude_interpolator</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">ax3</span><span class="p">,</span> <span class="n">latitude_interpolator</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>

        <span class="c1"># Return the interpolated and extrapolated value</span>
        <span class="k">return</span> <span class="n">longitude_interpolator</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adrian Marin Mag.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>